CREATE OR REPLACE PACKAGE cwf_audit 
authid current_user -- required by audit_create_triggers
as

  /******************************************************************************
     name:       cwf_audit
     purpose:    inserts, update, delete registration
  
     revisions:
     ver        date        author           description
     ---------  ----------  ---------------  ------------------------------------
     1.0        2010-04-06  Maciej Szymczak  created this package
  ******************************************************************************/


   -- This procedures create/drop audit triggers for all tables CWF_T% and CWF_D%
   
   --begin cwf_audit.audit_drop_triggers; cwf_audit.audit_create_triggers; end;
   procedure audit_drop_triggers;
   procedure audit_create_triggers;
  
   /*
   DETAILED INFORMATION 
   Sample code generated by this trigger is
   --
           CREATE OR REPLACE TRIGGER CWDATA.audit_AINT_t 
           before insert or update or delete
           on CWDATA.CWF_T_APPLICATION_HEADERS
           referencing new as new old as old
           for each row
           declare
             --2010.03.31 Maciej Szymczak, audit data mechanizm
             currentOperation varchar2(10);
           begin
            case
              when inserting then currentOperation := 'INSERT';
              when updating  then currentOperation := 'UPDATE';
              when deleting  then currentOperation := 'DELETE';
            end case;
            cwf_audit.audit_init(nvl(:new.id,:old.id), 'CWDATA','CWF_T_APPLICATION_HEADERS',currentOperation);
            cwf_audit.audit_insert('APPLICATION_DATE',:old.APPLICATION_DATE,:new.APPLICATION_DATE);
            cwf_audit.audit_insert('APPL_REG_DATE',:old.APPL_REG_DATE,:new.APPL_REG_DATE);
            cwf_audit.audit_insert('BROK_REG_DATE',:old.BROK_REG_DATE,:new.BROK_REG_DATE);
            cwf_audit.audit_insert('APPLICATION_NUMBER',:old.APPLICATION_NUMBER,:new.APPLICATION_NUMBER);
            cwf_audit.audit_insert('TOTAL_AMOUNT',:old.TOTAL_AMOUNT,:new.TOTAL_AMOUNT);
            cwf_audit.audit_insert('PRODUCTS_COUNT',:old.PRODUCTS_COUNT,:new.PRODUCTS_COUNT);
           end;
           
   NOTE, that information saved in fields ginitiator_login, ginitiator_id is wrong during operation DELETE (trigger has no info about the user).
         if CW that information is useless because there is an assuption records will never delete from the transactional tables.
         Still, information in column SESSIONID is right.         
   --
   Audit table structure is
   --
           create sequence cwf_main_seq;
           create sequence audit_transaction_id_s;
           CREATE TABLE AUDIT_DATA
           (
             ID                    NUMBER                  NOT NULL,
             SOURCE_ID             NUMBER                  NOT NULL,
             SOURCE_SCHEMA_NAME    VARCHAR2(30 BYTE)       NOT NULL,
             SOURCE_TABLE_NAME     VARCHAR2(30 BYTE)       NOT NULL,
             SOURCE_COLUMN_NAME    VARCHAR2(30 BYTE)       NOT NULL,
             SOURCE_VALUE_CONTEXT  VARCHAR2(255 BYTE),
             OLD_VALUE             VARCHAR2(4000 BYTE),
             NEW_VALUE             VARCHAR2(4000 BYTE),
             OPERATION_TYPE        VARCHAR2(10 BYTE)       NOT NULL,
             OPERATION_TIME        TIMESTAMP(6)            NOT NULL,
             INITIATOR_IP          VARCHAR2(15 BYTE),
             INITIATOR_LOGIN       VARCHAR2(255 BYTE),
             SESSIONID             NUMBER,
             TRANSACTION_ID        NUMBER
           );
           COMMENT ON TABLE AUDIT_DATA IS 'ENCJA = Tabela audytowa * ALIAS = AUDA';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_ID IS 'ATRYBUT ENCJI =  * OPIS = Unikalny identyfikator rekordu audytowanej tabeli * XML ELEMENT = AUDA_SOURCE_ID';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_SCHEMA_NAME IS 'ATRYBUT ENCJI =  * OPIS = Nazwa schematu z ktorego pochodzi audytowana tabela * XML ELEMENT = AUDA_SOURCE_SCHEMA_NAME';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_TABLE_NAME IS 'ATRYBUT ENCJI =  * OPIS = Nazwa audytowanej tabeli * XML ELEMENT = AUDA_SOURCE_TABLE_NAME';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_COLUMN_NAME IS 'ATRYBUT ENCJI =  * OPIS = Nazwa audytowanej kolumny * XML ELEMENT = AUDA_SOURCE_COLUMN_NAME';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_VALUE_CONTEXT IS 'ATRYBUT ENCJI =  * OPIS = Dodatkowa informacja opisujaca kontekst uzycia danej kolumny (np. dla referencji do slownikow znaczenie danej kolumny) * XML ELEMENT = AUDA_SOURCE_VALUE_CONTEXT';
           COMMENT ON COLUMN AUDIT_DATA.OLD_VALUE IS 'ATRYBUT ENCJI =  * OPIS = Wartosc kolumny przed zmiana (konwersja do VARCHAR) - przy INSERT = NULL * XML ELEMENT = AUDA_OLD_VALUE';
           COMMENT ON COLUMN AUDIT_DATA.NEW_VALUE IS 'ATRYBUT ENCJI =  * OPIS = Wartosc kolumny po zmianie (konwersja do VARCHAR) - przy DELETE = NULL * XML ELEMENT = AUDA_NEW_VALUE';
           COMMENT ON COLUMN AUDIT_DATA.OPERATION_TYPE IS 'ATRYBUT ENCJI =  * OPIS = Typ operacji: INSERT, UPDATE, DELETE * XML ELEMENT = AUDA_OPERATION_TYPE';
           COMMENT ON COLUMN AUDIT_DATA.OPERATION_TIME IS 'ATRYBUT ENCJI =  * OPIS = Dokladny czas dokonania zmiany * XML ELEMENT = AUDA_OPERATION_TIME';
           COMMENT ON COLUMN AUDIT_DATA.INITIATOR_IP IS 'ATRYBUT ENCJI =  * OPIS = Adres IP stacji roboczej z ktroej dokonano zmiany * XML ELEMENT = AUDA_INITIATOR_IP';
           COMMENT ON COLUMN AUDIT_DATA.INITIATOR_LOGIN IS 'ATRYBUT ENCJI =  * OPIS = Login osoby, ktora dokonala zmiany * XML ELEMENT = AUDA_INITIATOR_LOGIN';
           CREATE UNIQUE INDEX AUDA_PK ON AUDIT_DATA(ID);
           ALTER TABLE AUDIT_DATA ADD (CONSTRAINT AUDA_PK PRIMARY KEY (ID));
   */        
  
   ---------------------------------------------------------------------------------------------------------------------------------------------------------
   -- used by audit triggers
   procedure audit_init
    (psource_id             number                  
    ,psource_schema_name    varchar2       
    ,psource_table_name     varchar2       
    ,poperation_type        varchar2
    ,pinitiator_ip          varchar2
    ,pinitiator_login       varchar2
    );
       
   -- used by audit triggers
   procedure audit_insert
      (psource_column_name    varchar2       
      ,pold_value             varchar2
      ,pnew_value             varchar2
   );
    
 end cwf_audit;
/


CREATE OR REPLACE PACKAGE BODY cwf_audit  as 

  gsource_id             number;                  
  gsource_schema_name    varchar2(30);       
  gsource_table_name     varchar2(30);       
  goperation_type        varchar2(10);       
  gtransaction_id        number;
  ginitiator_ip          varchar2(30);
  ginitiator_login       varchar2(255);

 ---------------------------------------------------------------------------------------------------------------------------------------------------------
 procedure audit_init
    (psource_id             number                  
    ,psource_schema_name    varchar2       
    ,psource_table_name     varchar2       
    ,poperation_type        varchar2
    ,pinitiator_ip          varchar2
    ,pinitiator_login       varchar2
    ) is
 begin
    gsource_id           := psource_id;                  
    gsource_schema_name  := psource_schema_name;       
    gsource_table_name   := psource_table_name;       
    goperation_type      := poperation_type;
    ginitiator_ip        := pinitiator_ip;
    ginitiator_login     := pinitiator_login;
    select audit_transaction_id_s.nextval into gtransaction_id from dual;
 end;    

 ---------------------------------------------------------------------------------------------------------------------------------------------------------
 procedure audit_insert
    (psource_column_name    varchar2       
    ,pold_value             varchar2
    ,pnew_value             varchar2
 ) is
 begin
 if nvl(pold_value,'<null>') = nvl(pnew_value,'<null>') then
   --no change 
   return; 
 end if; 
 insert into audit_data (id, source_id, source_schema_name, source_table_name
                       , source_column_name, source_value_context, old_value, new_value
                       , operation_type, operation_time, initiator_ip, initiator_login, sessionid, transaction_id )
   values (cwf_main_seq.nextval, gsource_id, gsource_schema_name, gsource_table_name
                       , psource_column_name, null, pold_value, pnew_value
                       , goperation_type, localtimestamp, ginitiator_ip, ginitiator_login, userenv('SESSIONID'), gtransaction_id );
 end;      
 
procedure audit_create_triggers is
 
 sqlStatement varchar2(32000);    
 cols varchar2(32000);    
begin
 --specific to DNB: check uniqueless of table aliases
 declare
  r number;
 begin
     select count(*)
     into r
     from
     ( select cwf_tools.getTableAlias(owner,table_name) table_alias, count(*)
         from all_tables where owner = 'CWDATA' and ( table_name like 'CWF_T%' or table_name like 'CWF_D%' )
          and table_name not in ('CWF_T_GENDOC_REQUESTS','CWF_T_TEST_TOOL_RESULTS','CWF_D_DOSSIER_RANGE','CWF_T_RHK_XML')
       group by cwf_tools.getTableAlias(owner,table_name)
       having count(*)>1 );
  if r > 0 then raise_application_error(-20000, 'Nonunique table aliases !'); end if;    
  --select table_name, cwf_tools.getTableAlias(owner,table_name) table_alias  from all_tables where owner = 'CWDATA' and ( table_name like 'CWF_T%' or table_name like 'CWF_D%' )
  --and cwf_tools.getTableAlias(owner,table_name) in ('ADDRESS','AINT')
 end;    
 for rec in (
    select owner
        ,  table_name
        ,  cwf_tools.getTableAlias(owner,table_name) table_alias
    from all_tables x
   where owner = 'CWDATA' and ( table_name like 'CWF_T%' or table_name like 'CWF_D%' )
     and table_name not in ('CWF_T_GENDOC_REQUESTS','CWF_T_TEST_TOOL_RESULTS','CWF_D_DOSSIER_RANGE','CWF_T_RHK_XML')
     and exists ( select 1 from all_tab_cols where owner = x.owner and table_name = x.table_name and column_name = 'ID' ) 
      --and table_name = 'CWF_D_EXCHANGE_RATES'
     )
 loop
  sqlStatement := 
  'create or replace trigger '||rec.owner||'.cwf_audit_'||rec.table_alias||'_t '||chr(10)||
  'after insert or update or delete'||chr(10)|| 
  'on '||rec.owner||'.'||rec.table_name||chr(10)|| 
  'referencing new as new old as old'||chr(10)|| 
  'for each row'||chr(10)||
  'declare'||chr(10)||
  '  --2010.03.31 Maciej Szymczak, audit data mechanism, do not change this trigger manually. Instead of this, run cwf_audit.audit_create_triggers procedure'||chr(10)||
  '  currentOperation varchar2(10);'||chr(10)||
  'begin'||chr(10)|| 
  ' case'||chr(10)|| 
  '   when inserting then currentOperation := ''INSERT'';'||chr(10)||
  '   when updating  then currentOperation := ''UPDATE'';'||chr(10)||
  '   when deleting  then currentOperation := ''DELETE'';'||chr(10)||
  ' end case;'||chr(10)||
  ' cwf_audit.audit_init(nvl(:new.id,:old.id), '''||rec.owner||''','''||rec.table_name||''',currentOperation,  nvl(:new.last_updated_by_ip,:old.last_updated_by_ip), nvl(:new.last_updated_by_login,:old.last_updated_by_login));'||chr(10);
  cols := null;
  for rec2 in ( select column_name from all_tab_cols where owner = rec.owner and table_name = rec.table_name and virtual_column = 'NO' and column_name not in ('ID', 'CREATED_BY_LOGIN', 'CREATED_BY_IP', 'CREATION_DATE', 'LAST_UPDATED_BY_LOGIN', 'LAST_UPDATED_BY_IP', 'LAST_UPDATE_DATE') order by column_id )
  loop
      cols := cols || ' cwf_audit.audit_insert('''||rec2.column_name||''',:old.'||rec2.column_name||',:new.'||rec2.column_name||');'||chr(10);
  end loop;
  sqlStatement := sqlStatement || cols || 'end;';
  begin
  execute immediate sqlStatement;
  exception
    when others then
      raise_application_error(-20000, 'statement for table "'||rec.table_name||'"' || sqlerrm);
  end;
end loop;
end;
                 
procedure audit_drop_triggers is
 sqlStatement varchar2(32000);    
begin
 --specific to DNB: check uniqueless of table aliases
 for rec in (
    select owner
        ,  table_name
        ,  cwf_tools.getTableAlias(owner,table_name) table_alias
    from all_tables x
   where owner = 'CWDATA' and ( table_name like 'CWF_T%' or table_name like 'CWF_D%' )
     and table_name not in ('CWF_T_GENDOC_REQUESTS','CWF_T_TEST_TOOL_RESULTS','CWF_D_DOSSIER_RANGE','CWF_T_RHK_XML')
     and exists ( select 1 from all_tab_cols where owner = x.owner and table_name = x.table_name and column_name = 'ID' ) 
      --and table_name = 'CWF_D_EXCHANGE_RATES'
     )
 loop
  sqlStatement := 
  'drop trigger '||rec.owner||'.cwf_audit_'||rec.table_alias||'_t ';
  begin
    execute immediate sqlStatement;
  exception
    when others then
      null;
      --raise_application_error(-20000, 'statement for table "'||rec.table_name||'"' || sqlerrm);
  end;
end loop;
end;


end cwf_audit;
/

