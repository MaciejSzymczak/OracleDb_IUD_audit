create or replace PACKAGE custom_audit 
authid current_user -- required by audit_create_triggers
as

  /******************************************************************************
     name:       custom_audit
     purpose:    inserts, update, delete registration
  
     revisions:
     ver        date        author           description
     ---------  ----------  ---------------  ------------------------------------
     1.0        2010-04-06  Maciej Szymczak  created this package
     2.0        2017-01-16  Maciej Szymczak  updates
  ******************************************************************************/


   -- This procedures create/drop audit triggers for all tables custom_T% and custom_D%
   
   --begin custom_audit.audit_drop_triggers; custom_audit.audit_create_triggers; end;
   procedure audit_drop_triggers;
   procedure audit_create_triggers;
  
   /*
   DETAILED INFORMATION 
   Sample code generated by this trigger is
   --
           CREATE OR REPLACE TRIGGER CWDATA.audit_AINT_t 
           before insert or update or delete
           on CWDATA.custom_T_APPLICATION_HEADERS
           referencing new as new old as old
           for each row
           declare
             --2010.03.31 Maciej Szymczak, audit data mechanizm
             currentOperation varchar2(10);
           begin
            case
              when inserting then currentOperation := 'INSERT';
              when updating  then currentOperation := 'UPDATE';
              when deleting  then currentOperation := 'DELETE';
            end case;
            custom_audit.audit_init(nvl(:new.id,:old.id), 'CWDATA','custom_T_APPLICATION_HEADERS',currentOperation);
            custom_audit.audit_insert('APPLICATION_DATE',:old.APPLICATION_DATE,:new.APPLICATION_DATE);
            custom_audit.audit_insert('APPL_REG_DATE',:old.APPL_REG_DATE,:new.APPL_REG_DATE);
            custom_audit.audit_insert('BROK_REG_DATE',:old.BROK_REG_DATE,:new.BROK_REG_DATE);
            custom_audit.audit_insert('APPLICATION_NUMBER',:old.APPLICATION_NUMBER,:new.APPLICATION_NUMBER);
            custom_audit.audit_insert('TOTAL_AMOUNT',:old.TOTAL_AMOUNT,:new.TOTAL_AMOUNT);
            custom_audit.audit_insert('PRODUCTS_COUNT',:old.PRODUCTS_COUNT,:new.PRODUCTS_COUNT);
           end;
           
   NOTE, that information saved in fields ginitiator_login, ginitiator_id is wrong during operation DELETE (trigger has no info about the user).
         if CW that information is useless because there is an assuption records will never delete from the transactional tables.
         Still, information in column SESSIONID is right.         
   --
   Audit table structure is
   --
           create sequence custom_main_seq;
           create sequence audit_transaction_id_s;
           CREATE TABLE AUDIT_DATA
           (
             ID                    NUMBER                  NOT NULL,
             SOURCE_ID             NUMBER                  NOT NULL,
             SOURCE_SCHEMA_NAME    VARCHAR2(30 BYTE)       NOT NULL,
             SOURCE_TABLE_NAME     VARCHAR2(30 BYTE)       NOT NULL,
             SOURCE_COLUMN_NAME    VARCHAR2(30 BYTE)       NOT NULL,
             SOURCE_VALUE_CONTEXT  VARCHAR2(255 BYTE),
             OLD_VALUE             VARCHAR2(4000 BYTE),
             NEW_VALUE             VARCHAR2(4000 BYTE),
             OPERATION_TYPE        VARCHAR2(10 BYTE)       NOT NULL,
             OPERATION_TIME        TIMESTAMP(6)            NOT NULL,
             INITIATOR_IP          VARCHAR2(15 BYTE),
             INITIATOR_LOGIN       VARCHAR2(255 BYTE),
             SESSIONID             NUMBER,
             TRANSACTION_ID        NUMBER
           );
           COMMENT ON TABLE AUDIT_DATA IS 'ENCJA = Tabela audytowa * ALIAS = AUDA';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_ID IS 'ATRYBUT ENCJI =  * OPIS = Unikalny identyfikator rekordu audytowanej tabeli * XML ELEMENT = AUDA_SOURCE_ID';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_SCHEMA_NAME IS 'ATRYBUT ENCJI =  * OPIS = Nazwa schematu z ktorego pochodzi audytowana tabela * XML ELEMENT = AUDA_SOURCE_SCHEMA_NAME';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_TABLE_NAME IS 'ATRYBUT ENCJI =  * OPIS = Nazwa audytowanej tabeli * XML ELEMENT = AUDA_SOURCE_TABLE_NAME';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_COLUMN_NAME IS 'ATRYBUT ENCJI =  * OPIS = Nazwa audytowanej kolumny * XML ELEMENT = AUDA_SOURCE_COLUMN_NAME';
           COMMENT ON COLUMN AUDIT_DATA.SOURCE_VALUE_CONTEXT IS 'ATRYBUT ENCJI =  * OPIS = Dodatkowa informacja opisujaca kontekst uzycia danej kolumny (np. dla referencji do slownikow znaczenie danej kolumny) * XML ELEMENT = AUDA_SOURCE_VALUE_CONTEXT';
           COMMENT ON COLUMN AUDIT_DATA.OLD_VALUE IS 'ATRYBUT ENCJI =  * OPIS = Wartosc kolumny przed zmiana (konwersja do VARCHAR) - przy INSERT = NULL * XML ELEMENT = AUDA_OLD_VALUE';
           COMMENT ON COLUMN AUDIT_DATA.NEW_VALUE IS 'ATRYBUT ENCJI =  * OPIS = Wartosc kolumny po zmianie (konwersja do VARCHAR) - przy DELETE = NULL * XML ELEMENT = AUDA_NEW_VALUE';
           COMMENT ON COLUMN AUDIT_DATA.OPERATION_TYPE IS 'ATRYBUT ENCJI =  * OPIS = Typ operacji: INSERT, UPDATE, DELETE * XML ELEMENT = AUDA_OPERATION_TYPE';
           COMMENT ON COLUMN AUDIT_DATA.OPERATION_TIME IS 'ATRYBUT ENCJI =  * OPIS = Dokladny czas dokonania zmiany * XML ELEMENT = AUDA_OPERATION_TIME';
           COMMENT ON COLUMN AUDIT_DATA.INITIATOR_IP IS 'ATRYBUT ENCJI =  * OPIS = Adres IP stacji roboczej z ktroej dokonano zmiany * XML ELEMENT = AUDA_INITIATOR_IP';
           COMMENT ON COLUMN AUDIT_DATA.INITIATOR_LOGIN IS 'ATRYBUT ENCJI =  * OPIS = Login osoby, ktora dokonala zmiany * XML ELEMENT = AUDA_INITIATOR_LOGIN';
           CREATE UNIQUE INDEX AUDA_PK ON AUDIT_DATA(ID);
           ALTER TABLE AUDIT_DATA ADD (CONSTRAINT AUDA_PK PRIMARY KEY (ID));
   */        
  
   ---------------------------------------------------------------------------------------------------------------------------------------------------------
   -- used by audit triggers
   procedure audit_init
    (psource_id             varchar2                  
    ,psource_schema_name    varchar2       
    ,psource_table_name     varchar2       
    ,poperation_type        varchar2
    ,pinitiator_ip          varchar2
    ,pinitiator_login       varchar2
    );
       
   -- used by audit triggers
   procedure audit_insert
      (psource_column_name    varchar2       
      ,pold_value             varchar2
      ,pnew_value             varchar2
   );
  function getTableAlias ( pOwner varchar2,  pTableName varchar2, no_data_found_exception varchar2 default 'Y') return varchar2;
  function extractWord  (poz number, words varchar, sep varchar := '|') return varchar;
  
 end custom_audit;
/


create or replace PACKAGE BODY custom_audit  as 

  gsource_id             varchar2(15);                  
  gsource_schema_name    varchar2(30);       
  gsource_table_name     varchar2(30);       
  goperation_type        varchar2(10);       
  gtransaction_id        number;
  ginitiator_ip          varchar2(30);
  ginitiator_login       varchar2(255);

 ---------------------------------------------------------------------------------------------------------------------------------------------------------
 procedure audit_init
    (psource_id             varchar2                  
    ,psource_schema_name    varchar2       
    ,psource_table_name     varchar2       
    ,poperation_type        varchar2
    ,pinitiator_ip          varchar2
    ,pinitiator_login       varchar2
    ) is
 begin
    gsource_id           := psource_id;                  
    gsource_schema_name  := psource_schema_name;       
    gsource_table_name   := psource_table_name;       
    goperation_type      := poperation_type;
    ginitiator_ip        := pinitiator_ip;
    ginitiator_login     := pinitiator_login;
    select audit_transaction_id_s.nextval into gtransaction_id from dual;
 end;    

 ---------------------------------------------------------------------------------------------------------------------------------------------------------
 procedure audit_insert
    (psource_column_name    varchar2       
    ,pold_value             varchar2
    ,pnew_value             varchar2
 ) is
 begin
 if nvl(pold_value,'<null>') = nvl(pnew_value,'<null>') then
   --no change 
   return; 
 end if; 
 insert into audit_data (id, source_id, source_schema_name, source_table_name
                       , source_column_name, source_value_context, old_value, new_value
                       , operation_type, operation_time, initiator_ip, initiator_login, sessionid, transaction_id )
   values (custom_main_seq.nextval, gsource_id, gsource_schema_name, gsource_table_name
                       , psource_column_name, null, pold_value, pnew_value
                       , goperation_type, localtimestamp, ginitiator_ip, ginitiator_login, userenv('SESSIONID'), gtransaction_id );
 end;      

---------------------------------------------------------------------------------------------------------------------------------------------------------- 
procedure audit_create_triggers is
 sqlStatement varchar2(32000);    
 cols varchar2(32000);    
begin
 --specific to DNB: check uniqueless of table aliases
 declare
  r number;
 begin
     select count(*)
     into r
     from
     ( select custom_audit.getTableAlias(owner,table_name) table_alias, count(*)
         from all_tables
         where owner = 'LFPROD' and  table_name like 'DM%' and  table_name not like 'DM_TMP%' and table_name not in ('DM_PLANNINGPERIODS','DM_PLANNINGPERIODS_H','DM_DELETEME')
       group by custom_audit.getTableAlias(owner,table_name)
       having count(*)>1 );
  if r > 0 then raise_application_error(-20000, 'Nonunique table aliases !'); end if;    
  --select table_name, custom_audit.getTableAlias(owner,table_name) table_alias  from all_tables where owner = 'CWDATA' and ( table_name like 'custom_T%' or table_name like 'custom_D%' )
  --and custom_audit.getTableAlias(owner,table_name) in ('ADDRESS','AINT')
 end;    
 for rec in (
    select owner
        ,  table_name
        ,  custom_audit.getTableAlias(owner,table_name) table_alias
    from all_tables x
    where owner = 'LFPROD' and  table_name like 'DM%' and  table_name not like 'DM_TMP%'  and table_name not in ('DM_PLANNINGPERIODS','DM_PLANNINGPERIODS_H','DM_DELETEME')
     and exists ( select 1 from all_tab_cols where owner = x.owner and table_name = x.table_name and column_name = 'ID' ) 
      --and table_name = 'custom_D_EXCHANGE_RATES'
     )
 loop
  sqlStatement := 
  'create or replace trigger '||rec.owner||'.custom_audit_'||rec.table_alias||'_t '||chr(10)||
  'after insert or update or delete'||chr(10)|| 
  'on '||rec.owner||'.'||rec.table_name||chr(10)|| 
  'referencing new as new old as old'||chr(10)|| 
  'for each row'||chr(10)||
  'declare'||chr(10)||
  '  -- @author Maciej Szymczak, audit data mechanism, do not change this trigger manually. Instead of this, run custom_audit.audit_create_triggers '||chr(10)||
  '  currentOperation varchar2(10);'||chr(10)||
  'begin'||chr(10)|| 
  ' case'||chr(10)|| 
  '   when inserting then currentOperation := ''INSERT'';'||chr(10)||
  '   when updating  then currentOperation := ''UPDATE'';'||chr(10)||
  '   when deleting  then currentOperation := ''DELETE'';'||chr(10)||
  ' end case;'||chr(10)||
  ' custom_audit.audit_init(nvl(:new.id,:old.id), '''||rec.owner||''','''||rec.table_name||''',currentOperation,  nvl(null,null), nvl(:new.LASTMODIFIEDBYID,:old.LASTMODIFIEDBYID));'||chr(10);
  cols := null;
  for rec2 in ( select column_name from all_tab_cols where owner = rec.owner and table_name = rec.table_name and virtual_column = 'NO' and column_name not in ('ID', 'CREATEDDATE', 'CREATEDBYID', 'LASTMODIFIEDDATE', 'LASTMODIFIEDBYID','UPDATE_ME') order by column_id )
  loop
      cols := cols || ' custom_audit.audit_insert('''||rec2.column_name||''',:old.'||rec2.column_name||',:new.'||rec2.column_name||');'||chr(10);
  end loop;
  sqlStatement := sqlStatement || cols || 'end;';
  begin
  execute immediate sqlStatement;
  exception
    when others then
      raise_application_error(-20000, 'statement for table "'||rec.table_name||'"' || sqlerrm);
  end;
end loop;
end;
                 
--------------------------------------------------------------------------------------------------------------------------------------------------
procedure audit_drop_triggers is
 sqlStatement varchar2(32000);    
begin
 --specific to DNB: check uniqueless of table aliases
 for rec in (
    select owner
        ,  table_name
        ,  custom_audit.getTableAlias(owner,table_name) table_alias
    from all_tables x
   where owner = 'LFPROD' and  table_name like 'DM%' and  table_name not like 'DM_TMP%'  and table_name not in ('DM_PLANNINGPERIODS','DM_PLANNINGPERIODS_H','DM_DELETEME')
     and exists ( select 1 from all_tab_cols where owner = x.owner and table_name = x.table_name and column_name = 'ID' ) 
      --and table_name = 'EXCHANGE_RATES'
     )
 loop
  sqlStatement := 
  'drop trigger '||rec.owner||'.custom_audit_'||rec.table_alias||'_t ';
  begin
    execute immediate sqlStatement;
  exception
    when others then
      null;
      --raise_application_error(-20000, 'statement for table "'||rec.table_name||'"' || sqlerrm);
  end;
end loop;
end;


 ---------------------------------------------------------------------------------------------------------------------------------------------------------
   function extractWord  (poz number, words varchar, sep varchar := '|') return varchar is
     word varchar2(5000):='';
     word2 varchar2(5000);
     str2 varchar2(5000):= words || sep;
   begin
     for i in 1..poz loop
      if i = 1 then
       word:=SUBSTR(str2,1,INSTR(str2,sep,poz)-1);
       word2:=str2;
      else
       word2 := SUBSTR(word2,LENGTH(word2)+2-LENGTH(SUBSTR(word2,INSTR(word2,sep,1))));
       word  := SUBSTR(word2,1,INSTR(word2,sep,1)-1);
      end if;
     end loop;
     return Word;
   end;
   
 ---------------------------------------------------------------------------------------------------------------------------------------------------------
 function getTableAlias ( pOwner varchar2, pTableName varchar2, no_data_found_exception varchar2 default 'Y' ) return varchar2 is
  res varchar2(100);
 begin
   select unique trim(custom_audit.extractWord(3, comments, '=')) alias
    into res
   from all_tab_comments where owner = pOwner
    and  trim(custom_audit.extractWord(3, comments, '=')) is not null
    and table_name = pTableName;
   return res;
 exception
   when others then
     if no_data_found_exception = 'Y' then raise_application_error(-20000, ' getTableAlias for "'||pTableName||'" caused an error:' || sqlerrm ); end if;
     return null;
 end;

end custom_audit;
/

